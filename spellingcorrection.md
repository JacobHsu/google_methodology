## 怎樣實現拼寫糾錯的功能？

在介紹如何糾錯之前，先講一個簡單的問題，如何查錯。注意這是兩個相關的，但並不相同的問題。

查錯比較簡單，只要告訴書寫者所寫的單詞是對了還是錯了即可；
糾錯就比較難了，不僅要判斷對錯，還要提示正確的寫法。
比如你寫"華盛頓"這個詞，寫成了Wasingdon，查一下字典很容易判斷是否有這個單詞，
但是，要找到正確的拼寫Washington，就頗費周章了。

### 查錯

對於查錯這個問題，最直截了當的回答是把字典中所有英文單詞在計算機中建立一個詞典，大家無論是使用word寫文檔，還是在Google提供的搜索中，在相應的軟件裡實現一個直接查字典的功能就好了。不過，字典怎麼設計，就有講究了。

第一種設計方法是採用排好序的線性數組

這樣採用二分查找，就可以判斷一個字符串的拼寫是否是正確的（在構詞學上稱為"合法"）。如果英語的單詞有25萬個，那麼做18次單詞的比對即可（2的18次方大約等於25萬）。如果再考慮到單詞的平均長度是6個字母，每次比對要進行六次，這樣一共就是108次比對。
當然，如果我們利用哈希表來存儲詞典，大約只要進行兩次單詞查找，就可以判斷一個單詞的拼寫是否合法。這樣只要比對字母12次左右。

第二種設計方法是二叉樹的樹狀結構。

在二叉樹中，一個根節點，有左右兩個子節點，或者說左右兩個枝杈。在字典使用的這種樹中，每個根節點下面有26個枝杈，因為英語的字母表裡有26個字母。當然，如果做德語的拼寫檢查就要有30個枝杈，做西班牙語的，就要有27個或者32個（西班牙語有5個雙字母），如果做一種適合所有語言的，分岔就更多了，但只要不超過256個，計算機實現起來都不困難。

採用樹狀檢查拼寫，辦法和我們人查字典差不多。先看第一個字母，假設是w，然後看第二個，發現是a，就沿著a的那個樹杈往下走，如果檢查"華盛頓"這個詞，到了Wasing就查不下去了，就知道有錯了。

採用樹狀的數據結構有兩個好處。首先就是速度快，一個要檢查的單詞有多少字母，只要查找那麼多次即可，比如平均只需要六次。當然，程序實現起來要比使用數組或者哈希表麻煩。但是這個結構一旦建成，可以做一件更有意義的事情，就是**提示拼寫**，因為當敲了一個單詞的前幾個字母后，根據樹狀查找，很容易被開頭那幾個字母的常用單詞提示出來，這個功能特別有用。這是第二個好處。

當然，如果在特定的場合，比如手機上，為了節省存儲空間，還可以用一種叫做"布隆過濾器"的算法壓縮存儲。

### 如何糾錯

這並非是個很容易的問題，我們需要從理論和工程兩個角度來回答。先從理論上回答。

當我們知道一個單詞寫錯了，我們如何判斷它所對應的正確拼寫可能是哪一種呢？

一般來講我們要看錯誤的拼寫和哪個正確的拼寫"相近"。但是，這個相近其實並不好度量。

比如"華盛頓"的錯誤拼寫`Wasingdon`和正確的拼寫`Washington`是否相近呢？我們感覺它們確實相近，但是這個錯誤拼寫其實和另一個英國人的名字Watingdon似乎更相近。

因此，有必要量化地度量一下這些單詞之間的相近程度，或者反過來說，差異程度。

要做這件事，就要定義一種差異程度的度量，在構詞學中，它被稱為"編輯距離"。

接下來我們就說說什麼是編輯距離（Editing Distance），它是如何計算的。
對比一下`Wasingdon`和`Washington`。我們刻板地把相同位置的字母一個一個地比較，那麼它就錯了六個或者七個字母，因為從Was之後所有的字母都錯位了。

| W | a | s | **i** | n | g | **d** | o | n |
| W | a | s | **h** | i | n | g | **t** | o | n |

但是，我們一般會認為Wasingdon只錯了兩個字母，即少了一個h，把t寫成了d。如果我把缺少掉的字母h用空格"－"表示，讓它和h對應，那麼後面的字母大多能夠對應起來。大家可以掃一眼下面的表格，我們依然用藍色表示正確的匹配，紅色表示錯誤的匹配。從這個表中你可以看出，標紅色的錯誤只有兩處。

| W | a | s | - | i | n | g | **d** | o | n |
| W | a | s | **h** | i | n | g | **t** | o | n |

接下來的問題是，上述兩個拼寫的編輯距離到底應該如何定義？
很清楚，應該用最小的差異來定義。也就是說，編輯距離是2，而不是6。

那麼接下來怎麼計算編輯距離呢？這就要用到維特比算法相類似的一種動態規划算法了。
這個算法的細節我們省略了，它的思想和維特比算法一樣，把一個指數複雜度的問題，變成一個平方複雜度的問題。具體到"華盛頓"這個單詞上，大約可以把18萬次計算，縮減到100次計算。
下面一個表格是採用動態規劃的方法，計算出的"華盛頓"正確拼法和錯誤拼法不同的對應方式字母之間的差異。
表中橫線上的是錯誤拼法，豎線上的是正確拼法。差異最小的對應方法，即用一個空格"－"對應丟失的h，用d對應t。


|   | W | a | s | i | n | g | D | o | n |
|---|---|---|---|---|---|---|---|---|---|
| W | 0 |   |   |   |   |   |   |   |   |  
| a |   | 0 |   |   |   |   |   |   |   |  
| s |   |   | 0 |   |   |   |   |   |   | 
| H |   |   |   | 1 |   |   |   |   |   |
| i |   |   |   | 1 |   |   |   |   |   |
| n |   |   |   |   | 1 |   |   |   |   | 
| g |   |   |   |   |   | 1 |   |   |   | 
| T |   |   |   |   |   |   | 2 |   |   | 
| o |   |   |   |   |   |   |   | 2 |   | 
| n |   |   |   |   |   |   |   |   | 2 |

對於所有的英語單詞，我們都可以兩兩找出它們的編輯距離。比如a和an差1，but和cut差1，tell和tail差2，等等。

因此，進行拼寫糾錯的第一步，就是對於那些在詞典裡沒有的單詞，找到和它們編輯距離比較小，比如相差只有一到兩個字母的單詞作為候選。對於上面例子中Wasingdon這個寫法，"華盛頓"的正確寫法Washington和英國人的名字Watingdon都可以作為候選。

接下來到底挑選哪個單詞來修正就有講究了。雖然前者相差兩個字母，後者只相差一個字母，看似後者更接近，但是，如果考慮到"華盛頓"這個詞本身出現的概率要比Watingdon高得多，通常似乎改正成為"Watingdo"更合理。
不過，凡事也有例外，如果上下文是討論1066年威廉征服這件事，還真有一個叫做Watingdon的家族跟隨威廉一世來到英國。因此，正確使用**上下文**很重要。事實上，稍微好一點的拼寫矯正都需要考慮上下文。而利用上下文做選擇，其實採用的還真是維特比算法。
